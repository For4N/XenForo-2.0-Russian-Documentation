# <a name="part0"></a>Основы контроллеров
На базовом уровне контроллеры-это код, который выполняется при посещении страницы в XF. Контроллеры обычно отвечают за обработку пользовательского ввода и передачу этого ввода в соответствующее место, которое, как правило, должно выполнять какое-либо действие (модель) базы данных или загружать визуальное содержимое (представление).

Когда пользователь переходит по ссылке, запрошенный URL-адрес направляется на определенный контроллер и действие контроллера. Смотрите [Основы маршрутизации](/documentation/RoutingBasics.md#part0). Например, в XF, если посетить URL-адрес, как `index.php?conversations/add` вы будете направлены на контоллер XF`\Pub\Controller\Conversation` и на метод(action) `add`.

Если вы посмотрите на этот класс в файловой системе (see [АвтоЗагрузчик](/documentation/GeneralConcepts.md#part3) for a description of how classes and file paths map to each other) вы заметите, что методы именуются с префиксом `action`. Все эти методы указывают на определенное действие контроллера. Таким образом, чтобы увидеть метод, участвующий при просмотре страницы `conversations/add` page mentioned above, смотрите `public function actionAdd()`.

Контроллеры XF возвращают объект ответа, который может быть следующих типов:

## <a name="part1"></a>Ответ "Представление(view)"
Это один из наиболее распространенных ответов, с которым вы будете иметь дело во время разработки XF. Контроллер, который возвращает ответ представления(view), обычно требует передачу трех аргументов. Класс представления (подробнее об этом ниже), имя шаблона и массив `$viewParams` - это данные, которые будут доступны в шаблоне.

Это пример действия контроллера, который возвращает ответ представления:
```php
public function actionExample()
{
    $hello = 'Hello';
    $world = 'world!';

    $viewParams = [
        'hello' => $hello,
        'world' => $world
    ];
    return $this->view('Demo:Example', 'demo_example', $viewParams);
}
```
Первый аргумент - это короткое имя класса для определенного класса представления. Этот класс может существовать или не существовать (часто он не должен существовать, мы рассмотрим классы представлений позже), но он должен иметь уникальное имя для контроллера и действия. As with other [Короткие имена классов](/documentation/GeneralConcepts.md#part5), the particular short class name above will resolve to `Demo\Pub\View\Example`. Again, `Pub` is inferred automatically from the controller type.

Второй аргумент - имя шаблона. В этом случае мы ищем шаблон с именем `demo_example`.

Третий аргумент представляет собой массив параметров/переменных шаблона, которые доступны представлению(view). Этот массив должен быть парой `key => value` (`ключ => значение`). В приведенном выше примере в шаблон передаются два параметра. Ключ (`key`) указывает имя переменной, доступной в шаблоне. Значение массива (`value`) указывает на значение параметра.

Итак, если бы в шаблоне `demo_example` было следующее содержимое:

```php
{$hello} {$world}
```
Шаблон выведет следующее:

```Hello world!```
## <a name="part2"></a>Ответ "Перенаправление(redirect)"
Этот ответ возвращается, когда вы хотите перенаправить пользователя на другой URL-адрес после выполнения какого-либо действия.

Обычно, после того, как пользователь отправил данные через форму, вы можете перенаправить его на другую страницу, например, вернуть пользователя к списку элементов.

Это пример действия контроллера, который возвращает перенаправление:
```php
public function actionRedirect()
{
    return $this->redirect($this->buildLink('demo/example'), 'This is a redirect message.', 'permanent');
}
```
Первый аргумент - URL для перенаправления. Данный пример перенаправит пользователя к `index.php?demo/example` .

Второй аргумент будет отображаться только в том случае, если форма передается по AJAX-запросу, который запрещает перенаправление. Результатом будет "flash-сообщение", которое появляется в верхней части экрана с выбранным сообщением. Вы можете не указывать собственное сообщение. Тогда, по умолчанию будет "ваши изменения были сохранены".

Третий аргумент по умолчанию имеет значение `temporary`, но вы также можете установить его в `permanent` в соответствии с примером выше. Единственное отличие здесь - это код ответа HTTP сервера. `Temporary`  идеально подходит в большинстве случаев, и он будет отвечать 303 кодом. `permanent` будет отвечать 301 кодом.

Вы можете вызвать постоянную переадресацию иным образом, существует определенный метод, который может быть использован следующим образом. Он также принимает аргумент "сообщение", но, как указано выше, это необязательно.

```php
public function actionRedirect()
{
    return $this->redirectPermanently($this->buildLink('demo/example'));
}
```
## <a name="part3"></a>Ответ "Ошибка(error)"
Как следует из названия, этот ответ - то, что вы вернете, пользователю. А именно - отобразите ошибку. 
Вот небольшой пример:
```php
public function actionError()
{
    return $this->error('Unfortunately the thing you are looking for could not be found.', 404);
}
```
Здесь поддерживаются только два аргумента. Первое - это сообщение об ошибке, которое вы хотите отобразить, а второе - код ответа HTTP, который вы хотите отправить серверу. 404 будет представлять соответствующий ответ, когда что-то не было найдено.

## <a name="part4"></a>Ответ "Сообщение(message)"
Этот ответ очень похож на ответ об ошибке и поддерживает те же аргументы. Основное различие заключается в том, что отображаемое сообщение не представляется как ошибка.

## <a name="part5"></a>Ответ "Исключение(exception)"
Иногда необходимо прервать нормальный поток кода вашего контроллера и вместо этого ответить Исключением. Ответы на исключения не обязательно должны представлять ошибку; например, они могут использоваться для принудительного перенаправления контроллера. Однако, как правило, они часто используются для остановки потока контроллера для отображения ошибки, как это показано в следующем примере:
```php
public function actionException()
{
    throw $this->exception($this->error('An unexpected error occurred'));
}
```
Исключения принимают только один аргумент, и фактически этот аргумент должен быть какой-либо другой формой объекта ответа, такой как [Ответ "Ошибка"](/documentation/ControllerBasics.md#part3). Данный конкретный пример бросает исключение, и весь код контроллера в той точке остановится, и будет отображена стандартная ошибка.

***Обратите внимание, что ответы на исключения должны быть "брошены" с помощью `throw`, а не "возвращены" с `return` .***

## <a name="part6"></a>Ответ "Перенаправление маршрута(reroute)"
Иногда необходимо перенаправить пользователя на совершенно другой контроллер или действие в том же контроллере, не выполняя полное перенаправление, не изменяя URL-адрес пользователя и не дублируя код целевого действия.

Это выглядит примерно так:
```php
public function actionReroute()
{
    return $this->rerouteController(__CLASS__, 'error');
}

public function actionError()
{
    return $this->error('Oops! Something went wrong!');
}
```
В данном примере, если пользователь посетил `index.php?demo/reroute`, они увидят ответ об ошибке из метода `actionError()`. Они не будут перенаправлены, и URL-адрес в их браузере не изменится; они просто получат ответ от действия ошибки.

Ответ reroute также поддерживает третий аргумент, который позволяет передавать различные параметры от одного действия контроллера к другому. Это может быть массив или объект `ParameterBag` (об этом позже).

## <a name="part7"></a>Правильное изменение ответа на действие контроллера
Из раздела [Расширение классов](/documentation/GeneralConcepts.md#part6), мы уже видели, как просто расширить класс, но необходимо проявлять особую осторожность при расширении действий контроллера, который уже существует.

Если у вас нет конкретной задачи полностью переопределить существующее действие и заменить его чем-то новым (что не рекомендуется), вместо этого вы должны изменить существующий ответ родительского класса. Это делается довольно просто, в качестве примера давайте изменим [Ответ "Просмотр"](/documentation/ControllerBasics.md#part1) из примера выше.
```php
public function actionExample()
{
    $reply = parent::actionExample();

    return $reply;
}
```
Предполагая, что вышеупомянутое добавлено к расширенному контроллеру, где метод `actionExample()` уже существует, вышеприведенный код ничего не делает, кроме возврата исходного ответа. Теперь изменим существующий параметр `hello` на `Bonjour`.
```php
public function actionExample()
{
    $reply = parent::actionExample();

    if ($reply instanceof \XF\Mvc\Reply\View)
    {
        $reply->setParam('hello', 'Bonjour');
    }

    return $reply;
}
```
Поскольку ответ контроллера может фактически представлять несколько различных объектов с различным поведением и методами, крайне важно, чтобы мы только попытались расширить правильный тип ответа. Мы делаем это в приведенном выше примере, проверяя, является ли родительский объект `$reply` типом представления(view). Если бы мы не сделали этого, и
расширили действие, а действие отвечало бы перенаправлением - была бы ошибка.

Перед расширением этого действия, посетив эту страницу будет отображаться "Hello world!". После его расширения, будет отображаться "Bonjour world!".