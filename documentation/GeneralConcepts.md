
# <a name="part0"></a>Общие понятия
В следующих разделах подробно рассказывается о некоторых общих системах и концепциях, с которыми вы столкнетесь при разработке дополнения XenForo. Если вы знакомы с разработкой XenForo 1.x, то многие из этих концепций будут вам знакомы, хотя стоит их рассмотреть, так как есть несколько отличных новых инструментов и функций, которые помогут вам разрабатывать надстройки.

## <a name="part1"></a>Компоненты поставщика
XF2 не оснащен инфраструктурой specificc, поскольку XF1 был, однако, мы использовали использование некоторых популярных, хорошо протестированных пакетов с открытым исходным кодом, чтобы помочь в решении конкретных задач. Например, мы используем проект SwiftMailer для отправки электронной почты и проект с именем Guzzle в качестве HTTP-клиента. Все сторонние проекты загружаются из каталога `src/vendor`.

В настоящее время разработчики дополнений не могут добавлять свои собственные зависимости к этому местоположению.

## <a name="part2"></a>Интегрированная среда разработки (IDE)
Прежде чем приступать к работе над разработкой XF2, вы можете потратить некоторое время на оценку приложения, с которым вы действительно будете создавать и редактировать файлы PHP. Это обычно называют IDE. Существует ряд вариантов, начиная от базового Блокнота и заканчивая чем-то вроде Sublime Text, который может быть расширен, чтобы иметь лучшую поддержку PHP с надстройками, вплоть до правильной среды разработки, такой как PhpStorm. Внутри мы используем PhpStorm как нашу предпочтительную среду IDE. Это премиальный и коммерческий продукт, но могут быть доступны свободные альтернативы. В любом случае, никто не может сказать вам лучшее приложение для ваших требований, и вы должны потратить некоторое время на ряд продуктов (даже на бесплатные) и использовать этот опыт, чтобы узнать свои предпочтения.

## <a name="part3"></a>АвтоЗагрузчик
XF2 использует автозагрузчик, который автоматически создается Composer. Это позволяет автоматически включать весь код XF, код поставщика третьей стороны и любой дополнительный код разработчика для всего проекта без необходимости «включать/требовать» ваши классы вручную.

Корень автозагрузки для всех надстроек XF является каталогом `src/addons`. Это означает, что все ваши имена классов будут относиться к этому базовому местоположению. Также стоит отметить, что XF2 использует строгий шаблон «для каждого файла» для именования. Каждый файл должен содержать только один класс, а имя этого класса должно определять точное местоположение файла PHP класса в файловой системе.

Например, если вы хотите создать новый класс в файле с именем `src/addons/Demo/Setup.php` (где `Demo` - ваш дополнительный код), этот класс будет называться `Demo\Setup`. И наоборот, если бы у вас был класс с именем `Demo\Entity\Thing`, вы узнаете, что файл для этого класса находится в пути `src/addons/Demo/Entity/Thing.php`.

## <a name="part4"></a>Пространства имён
Всюду по XF мы используем [namespaces](http://php.net/manual/en/language.namespaces.rationale.php) так что мы можем более кратко ссылаться на классы в одном и том же пространстве имен. Рекомендуется, чтобы все надстройки также использовали пространства имен. В приведенном выше примере мы говорили о классе с именем `Demo\Setup`. Используя пространства имен, класс фактически будет называться просто «Setup», но пространство имен будет установлено в `Demo`. В качестве более конкретного примера мы также говорили выше о классе с именем `Demo\Entity\Thing`. Давайте посмотрим, как будет выглядеть код PHP для этого класса:
```
<?php

namespace Demo\Entity;

class Thing
{

}
```
Если в каталоге `src/addons/Demo/Entity` был класс с именем` AnotherThing`, мы могли бы ссылаться на этот класс в классе `Thing` просто как` AnotherThing`, потому что этот класс находится в том же `Demo\Entity` Пространство имен.

## <a name="part5"></a>Короткие имена классов
Иногда классы, указанные в XF, сокращаются. Например, если вы хотите вызвать сущность `User` (подробнее об объектах ниже), вы можете увидеть имя класса, на которое ссылается просто« XF: Пользователь ». Использование коротких имен классов и полного имени класса, к которому они разрешают, полностью зависит от контекста. Поэтому в контексте вызова сущности короткое имя класса будет разрешено для следующего полного имени класса `XF\Entity\User`. Часть `XF` указывает путь к файлу (на основе идентификатора add-on), часть` Entity` подразумевается путем вызова объекта, а часть `User` указывает на конкретный объект. Аналогично, когда вы начинаете создавать свои собственные классы, вы также будете использовать короткие имена классов для ссылки на свои собственные классы. Например, если вам нужно создать новую сущность `Thing` для вашего надстройки« Demo », вы должны написать следующее:
```php
\XF::em()->create('Demo:Thing');
```
Это разрешило бы класс `Demo\Entity\Thing`. Аналогичным образом, если вы хотите получить доступ к репозиторию `Thing`, вы должны написать его следующим образом:
```php
\XF::repository('Demo:Thing');
```
Обратите внимание, как короткие имена классов идентичны. Вызов репозитория фактически разрешит `Demo\Repository\Thing`.

## <a name="part6"></a>Расширение классов
Большое количество классов в XF2 является расширяемым, что позволяет разработчикам расширять и переопределять основной код без необходимости его прямого редактирования. Если вы знакомы с разработкой XF1, вы будете знакомы со следующим процессом:

1. Создание PHP-файла Listener
2. Создайте класс, который в конечном итоге расширит исходный класс
3. Напишите функцию, которая соответствует ожидаемой сигнатуре обратного вызова для одного из событий `load_class` и добавляет имя вашего расширенного класса
4. Добавьте в ACP «прослушиватель событий кода», который определяет класс и имя слушателя для функции, упомянутой выше, и необязательно намекает, какой класс расширяется

В XF2 мы удалили эти события в пользу определенной системы под названием «Расширения класса». Процесс выглядит следующим образом:

1. Создайте класс, который в конечном итоге расширит исходный класс
2. Добавьте «расширение класса» в ACP, которое указывает имя расширяемого класса и имя класса, который его расширяет
3. Это явно сокращает часть шаблона, требуемого для расширения классов, а также предоставляет специальный пользовательский интерфейс для просмотра и управления этими расширениями. Давайте посмотрим на процесс, расширив публичный контроллер `Member` и добавив новое действие, которое отображает простое сообщение.

Первое, что нужно сделать, это создать надстройку. Мы ранее описали, как это сделать, используя команду `xf-addon: create` [здесь] (/documentation/DevelopmentTools.md#part5). В этом примере мы предположим, что вы создали надстройку с идентификатором и названием «Demo».

Теперь у вас будет файл addon.json для этого дополнения в следующем расположении `src/addons/Demo/addon.json`.

> **Примечание**
> Хотя, строго говоря, вы можете размещать свои расширенные классы везде, где захотите, в своем дополнительном каталоге, рекомендуется поместить расширенные классы в каталог, который легко идентифицирует: a) надстройка класса принадлежит b) типу класса и c) название расширяемого класса. В следующих примерах мы расширяем публичный контроллер члена XF, поэтому мы разместим наш расширенный класс по следующему пути: `src/addons/Demo/XF/Pub/Controller/Member.php`.

Расширенный класс должен существовать до того, как мы добавим расширение класса в ACP. Итак, следуйте следующим инструкциям:

1. Создайте новый каталог с именем `XF` внутри `src/addons/Demo`
2. Создайте новый каталог с именем `Pub` внутри `src/addons/Demo/XF`
3. Создайте новый каталог с именем `Controller` внутри `src/addons/Demo/XF/Pub`
4. Создайте новый файл с именем `Member.php` внутри `src/addons/Demo/XF/Pub/Controller`. Исходное содержимое вашего PHP-файла должно быть следующим:
```php
<?php

namespace Demo\XF\Pub\Controller;

class Member extends XFCP_Member
{

}
```
Если вы знакомы с расширением PHP-классов в целом, но не знакомы с XF, приведенный выше пример может показаться запутанным. Причина этого заключается в том, что вы, возможно, ожидали расширить класс `XF\Pub\Controller\Member`, а не` XFCP_Member`. В XF мы используем систему «XenForo Class Proxy» (короткая версия XFCP) для создания «цепочки наследования», которая в конечном счете позволяет расширить один класс несколькими дополнениями. Соглашение должно ссылаться на фиктивный расширенный класс, который является текущим именем класса `Member` и префикс его с помощью `XFCP_`.

Теперь класс создан, мы можем создать расширение класса на странице расширения `ACP > Development > Class > Add` class extension.

Все, что вам нужно сделать, это ввести имя базового класса (`XF\Pub\Controller\Member`) в первом поле и имя расширенного класса (которое вы только что создали) во втором поле (`Demo\XF\Pub\Controller\Member`) и нажмите кнопку «Сохранить».

Расширение вашего класса теперь должно быть активным, но в настоящее время оно ничего не делает. Чтобы что-то произошло, нам необходимо либо переопределить существующий метод в этом классе, создав метод с тем же именем, что и существующий, либо полностью добавив новый метод. Давайте сделаем последнее:
```php
<?php

namespace Demo\XF\Pub\Controller;

class Member extends XFCP_Member
{
	public function actionHelloWorld()
	{
		return $this->message('Hello world!');
	}
}
```
Мы больше говорим о контроллерах, действиях и ответах на странице [Основы контроллера](/documentation/ControllerBasics.md#part0), поэтому не беспокойтесь об этом прямо сейчас.

Теперь мы добавили некоторый код в наш расширенный контроллер, давайте посмотрим его в действии. Просто введите следующий URL-адрес (относительно URL-адреса вашей доски): `index.php?members/hello-world`. Теперь вы должны увидеть «Hello world!». сообщение отображается!

Как упоминалось ранее, также возможно переопределить существующие методы внутри класса. Например, если мы изменили `actionHelloWorld()` на `actionIndex()`, то у вас больше не будет списка «Известные члены», вместо этого отобразится «Hello world!». сообщение! Это не совсем правильный способ расширения существующего действия контроллера (или любого метода класса), но мы подробно рассмотрим это в [Изменение ответа на действие контроллера (правильно)](/documentation/ControllerBasics.md#part7).

## <a name="part7"></a>Типовые подсказки
Многие объекты в XF создаются с помощью заводских методов. Например, если мы хотим создать экземпляр конкретного репозитория, мы напишем следующее:
```php
    $repo = \XF::repository('Demo:Thing');
```
Это очень удобный и последовательный способ создания объекта. Мы знаем, только посмотрев на него, какой объект будет создан. Полученный код в этом методе знает, как вернуть правильный объект для того, что мы запросили.

Однако, к сожалению, ваша IDE, вероятно, не имеет понятия (по крайней мере, по умолчанию). Что касается IDE, этот метод вернет экземпляр объекта `XF\Mvc\Entity\Repository`. Это полезно в определенной степени, но существует множество методов, доступных в конкретном объекте `Demo\Repository\Thing`, о котором ваша среда ID не знает. Это в конечном итоге означает, что, когда вы пытаетесь использовать свой объект `$repo` в коде, ваша среда IDE не сможет делать предложения или автоматически заполнять имена методов и требуемые аргументы.

Это подсказка типа становится полезной, и синтаксис должен поддерживаться стандартным большинством IDE и некоторыми текстовыми редакторами, знакомыми с PHP. Мы просто изменили бы наш запрос на репозиторий следующим образом:
```php
/** @var \Demo\Repository\Thing $repo */
$repo = \XF::repository('Demo:Thing');
```
Тип подсказки над вызовом репозитория теперь сообщает IDE, что `$ repo` относится к объекту, представленному классом `Demo\Repository\Thing`, а не к объекту, который он автоматически выводил изначально.

Тип подсказки особенно полезен при расширении классов. Потенциальная проблема с нашими методами расширения класса заключается в том, что по существу ваши классы не расширяют исходный класс, который вы хотите расширить, но вместо этого проксируется через класс, который фактически не существует, например. `XFCP_Member`, например, в [пример выше] (/documentation/GeneralConcepts.md#part6).

Чтобы исправить эту проблему, мы автоматически создаем файл с именем `extension_hint.php` и сохраняем его в вашем каталоге` _output`.

Это добавляет ссылку, которую IDE может читать, но PHP не может так, что среда IDE теперь понимает, что, когда мы используем `$this` внутри любого из методов этого расширенного класса, который он может предложить и автозаполнять методы и свойства, доступные в Member контроллер или один из его родителей.